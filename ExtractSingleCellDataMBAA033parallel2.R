library(tiff)
library(dplyr)
library(stringr)
library(doParallel)
library(png)
#library(concaveman)

aviablecores = commandArgs(trailingOnly = T)
if (rlang::is_empty(aviablecores)){
  aviablecores = 1
}
registerDoParallel(cores = aviablecores)

str_escape_plus <- function(string){
  string <- str_replace(string, "\\+", "\\\\+")
  return(string)
}

#the root folder where all data (export folders) is located
projectpath <- "/hpc/shared/sign/mbaars/CYTOFDATA/"
outputfolder <- projectpath
#Folder where segmentation maps are located relative to -export folder
LocationOfMaskFiles <- "cell-stack/prob/"
#Folder where input files are located relative to projectpath
LocationOfSlideScanImages <- paste0(projectpath, "MatchedSlideScanCrops/Scale-1/")
LocationOfSlideScanMasks <- paste0(projectpath, "MatchedSlideScanCrops/Mask-1/")
#specification of marker names used for nuclear/membrane specific quantification
NuclearMarkers <- c("193Ir","FOXP3","H3","Ki-67","NF-Kb","Tbet")
MembraneMarkers <- c("CD3","CD4","CD8a","CD14","CD16","CD20",
                     "CD45","CD45RO","CD68","CTLA-4","E-Cadherin",
                     "ICOS","Pan-Keratin","PD1","PD-L1","TCRgd")

#Naming convention on segmentation maps generated by cellprofiler
NameOfSingleCellMask <- str_escape_plus("_Probabilities_1_IF+IMC_SecondaryObjects.tiff")
NameOfSingleCellMaskEdges <- str_escape_plus("_Probabilities_1_IF+IMC_SecondaryObjectsEdges.tiff")
NameOfSingleCellNucleiMask <- str_escape_plus("_Probabilities_1_IF+IMC_PrimaryObjects.tiff")

read_rawdata_tiffs <- function(rawfolder){
  rawfilelist <- list.files(path = rawfolder, pattern = ".+(.tiff)$", full.names = TRUE)
  for (rawchannelindex in seq_along(rawfilelist)){
    if (rawchannelindex == 1){
      RAWDATA <- list()
    }
    channelname <- substr(basename(rawfilelist[rawchannelindex]), 0, regexpr("(.tiff)", basename(rawfilelist[rawchannelindex]))-1)
    if (regexpr("object", channelname) == -1){ 
      #exclude segmentation map from quantification channels, read all others to list
      RAWDATA[[channelname]] <- readTIFF(rawfilelist[rawchannelindex])
    }
  }
  return(RAWDATA)
}

coords_to_polygon <- function(coordinates){
  #Generate based on coordinates of all pixels belonging to current cell
  coordinates_rot <- data.frame(x = coordinates[,"col"], y = -coordinates[,"row"])
  coordinates_x1 <- data.frame(x = coordinates_rot[,"x"]+1, y = coordinates_rot[,"y"])
  coordinates_y1 <- data.frame(x = coordinates_rot[,"x"], y = coordinates_rot[,"y"]-1)
  coordinates_x1y1 <- data.frame(x = coordinates_rot[,"x"]+1, y = coordinates_rot[,"y"]-1)
  colnames(coordinates_x1y1) <- c("x","y")
  coordinates_tot <- rbind(coordinates_rot, coordinates_x1, coordinates_y1, coordinates_x1y1)
  coordinates_fixed <- coordinates_tot[!duplicated(coordinates_tot),]
  
  Polygon <- concaveman(as.matrix(coordinates_fixed), concavity = 1, length_threshold = 1)
  Polygon_fixed <- data.frame(x = Polygon[,"V1"], y = Polygon[,"V2"])
  return(Polygon_fixed)
}

mask_to_polygons <- function(mask, ROInrs){
  #Generate polygons based on coordinates of all pixels belonging to all individual cells
  CellPolygons <- foreach(i = seq_along(ROInrs), .packages = "concaveman") %dopar% {
    MaskCellIndexes <- which(mask == i, arr.ind = T)
    CellPolygonCoords <- coords_to_polygon(MaskCellIndexes)
  }
  CellPolygons <- bind_rows(CellPolygons, .id = "ROInr")
  return(CellPolygons)
}

read_slidescan_mask <- function(RegionNameSub, LocationOfSlideScanImages, LocationOfSlideScanMasks, P, R){
  #Find SlideScan Match
  SlideScanPattern <- paste0("^(", RegionNameSub, ")", ".+", "(_P-)", P,"(_R-)", R, ".+$")
  SlideScanFile <- list.files(path = LocationOfSlideScanImages, pattern = SlideScanPattern, full.names = T)
  SlideScanInfoReturn <- list()
  if (length(SlideScanFile) == 1){
    SlideScanMaskFile <- list.files(path = LocationOfSlideScanMasks, pattern = SlideScanPattern, full.names = T)
    if (length(SlideScanMaskFile) >= 1){
      #at least 1 mask found for this slidescan image
      SlideScanMaskFileName <- basename(SlideScanMaskFile)
      TissueType <- substr(SlideScanMaskFileName,
                            nchar(substr(basename(SlideScanFile), 0,
                            regexpr(".png", basename(SlideScanFile))-1))+2,
                            regexpr(pattern = "[(][0-9]+,[0-9]+,[0-9]+,[0-9]+[)]-mask.png",
                            SlideScanMaskFileName)-2)
      for (SlideScanMaskIndex in seq_along(SlideScanMaskFile)){
        SlideScanInfoReturn[[as.character(SlideScanMaskIndex)]][["mask"]] <- readPNG(SlideScanMaskFile[SlideScanMaskIndex], native = T, info = F)
        SlideScanInfoReturn[[as.character(SlideScanMaskIndex)]][["tissuetype"]] <- TissueType[SlideScanMaskIndex]
      }
    }
    else{
      #no mask found for slidescan image, healthy tissue type
      SlideScanInfoReturn[["1"]][["tissuetype"]] <- "Healthy"
      SlideScanInfoReturn[["1"]][["mask"]] <- ""
    }
  }
  else{
    #no slidescan image found, unknown tissue type
    SlideScanInfoReturn[["1"]][["tissuetype"]] <- "Unknown"
    SlideScanInfoReturn[["1"]][["mask"]] <- ""
  }
  return(SlideScanInfoReturn)
}

raw_to_single_cell_data <- function(RAWDATA, rawfolder, mask, ROInrs, 
                                    maskedgefile, masknuclfile, NuclearMarkers, 
                                    MembraneMarkers, SlideScanMaskData){
  if (length(maskedgefile) == 1){
    maskedge <- readTIFF(maskedgefile, as.is = T)
  }
  if (length(masknuclfile) == 1){
    masknucl <- readTIFF(masknuclfile, as.is = T)
  }
  
  AllSingleCellDataFrame <- foreach(i = seq_along(ROInrs), .combine = rbind) %dopar% {
    SingleCellDataFrame <- data.frame("ROInr" = i)
    
    MaskCellIndexes <- which(mask == i, arr.ind = T)
    MaskNuclIndexes <- which(masknucl == i, arr.ind = T)
    
    SingleCellDataFrame[, "Cell_Area"] <- length(MaskCellIndexes)
    SingleCellDataFrame[, "Nucl_Area"] <- length(MaskNuclIndexes)
	    
    if (length(maskedgefile) == 1){
      MaskEdgeIndexes <- MaskCellIndexes[which(maskedge[MaskCellIndexes] == 255, arr.ind = T)]
      SingleCellDataFrame[, "Edge_Area"] <- length(MaskEdgeIndexes)
    }
    else{
      MaskEdgeIndexes <- ""
    }
    for (channelindex in seq_along(RAWDATA)){
      channelname <- names(RAWDATA)[channelindex]
      RawCellData <- RAWDATA[[channelindex]][MaskCellIndexes]
      if (regexpr(".+Dist$", channelname) != -1){
        SingleCellDataFrame[, paste0(channelname, "_Min")] <- min(RawCellData)
      }
      else{
        SingleCellDataFrame[, paste0(channelname, "_Mean")] <- mean(RawCellData)
        SingleCellDataFrame[, paste0(channelname, "_Median")] <- median(RawCellData)
        SingleCellDataFrame[, paste0(channelname, "_Int")] <- sum(RawCellData) 
      }
      if (is.element(channelname, NuclearMarkers)){
        RawNuclData <- RAWDATA[[channelindex]][MaskNuclIndexes]
        SingleCellDataFrame[, paste0(channelname, "_Nucl_Mean")] <- mean(RawNuclData)
        SingleCellDataFrame[, paste0(channelname, "_Nucl_Median")] <- median(RawNuclData)
        SingleCellDataFrame[, paste0(channelname, "_Nucl_Int")] <- sum(RawNuclData)
      }
      if (length(MaskEdgeIndexes) > 1){
        if (is.element(channelname, MembraneMarkers)){
          RawEdgeData <- RAWDATA[[channelindex]][MaskEdgeIndexes]
          SingleCellDataFrame[, paste0(channelname, "_Edge_Mean")] <- mean(RawEdgeData)
          SingleCellDataFrame[, paste0(channelname, "_Edge_Median")] <- median(RawEdgeData)
        }
      }
    }
    # Supplement data from slide scan mask to single-cell data
    if (length(SlideScanMaskData) == 1 && SlideScanMaskData[[1]][["mask"]] == ""){
      # In case no mask file is found for current region
      # Cells are either in healthy or unkown area, depending on presence of aligned slidescan
      SingleCellDataFrame[,"TissueType"] <- SlideScanMaskData[[1]][["tissuetype"]]
      SingleCellDataFrame[,"Lymphoid"] <- F
    }
    else{
      # If at least 1 mask file is found
      SingleCellDataFrame[,"TissueType"] <- "Healthy"
      SingleCellDataFrame[,"Lymphoid"] <- F
      for (ScanMaskIndex in seq_along(SlideScanMaskData)){
        PartOfMask <- SlideScanMaskData[[ScanMaskIndex]][["mask"]][MaskCellIndexes] == -1
        if (sum(is.na(PartOfMask)) < 1){
          if (sum(PartOfMask)/length(PartOfMask) >= .5){
            # At least half of the pixels of a cell should be inside a zone
            TissueType <- SlideScanMaskData[[ScanMaskIndex]][["tissuetype"]]
            if (TissueType == "Lymphoid Structure"){
              SingleCellDataFrame[,"Lymphoid"] <- T
            }
            else{
              SingleCellDataFrame[,"TissueType"] <- TissueType
            }
          }
        }
        else {
          SingleCellDataFrame[,"Lymphoid"] <- F
          SingleCellDataFrame[,"TissueType"] <- NA
        }
      }
    }
    # Now return a df for a single-cell from the for each loop.
    SingleCellDataFrame
  }
  # Add sample information to single-cell data.
  RegionName <- basename(rawfolder)
  AllSingleCellDataFrame[, "MCDName"] <- substr(RegionName, 0, regexpr("_PN-", RegionName) -1)
  Pindex <- regexpr("_P[0-9]+[a-zA-Z]?_", RegionName)
  PatientNumber <- substr(RegionName, Pindex + 1, Pindex + attr(Pindex, "match.length") -2)
  if (PatientNumber != -1){
  		AllSingleCellDataFrame[, "Patient"] <- PatientNumber
  }
  AllSingleCellDataFrame[, "PanoName"] <- substr(RegionName, regexpr("_PN-", RegionName) +4, regexpr("_P-", RegionName) -1)
  AllSingleCellDataFrame[, "ROIName"] <- substr(RegionName, regexpr("_D-", RegionName) +3, nchar(RegionName))
  return(AllSingleCellDataFrame)
}

# Find all raw data folders in the defined exportfolder
DatasetFolderList <- list.files(path = projectpath, pattern = ".+(-export)", full.names = T)
for (FolderIndex in seq_along(DatasetFolderList)){
  if(FolderIndex == 1){
    RAWFolderList <- list.files(path = paste(DatasetFolderList[FolderIndex],
                                              "RAW/32-bit/", sep="/"), 
                                              full.names = T)
  }else{
    RAWFolderList <- c(RAWFolderList, 
                       list.files(path = paste(DatasetFolderList[FolderIndex],
                                                "RAW/32-bit/", sep="/"),
                                                full.names = T))
  }
}

for (RegionIndex in seq_along(RAWFolderList)){
  print(paste("Busy with",RegionIndex,"Of",length(RAWFolderList),sep=" "))
  #Extract information from the region foldername
  exportfolder <- dirname(dirname(dirname(RAWFolderList[RegionIndex])))
  RegionName <- basename(RAWFolderList[RegionIndex])
  print(RegionName)
  RegionNameSub <- substr(RegionName, 0, regexpr("_PN-", RegionName)-1)
  P <- substr(RegionName, regexpr("_P-", RegionName)+3, regexpr("_R-", RegionName)-1)
  R <- substr(RegionName, regexpr("_R-", RegionName)+3, regexpr("_D-", RegionName)-1)
  #Find the single-cell mask associated with the raw data
  maskpattern <- paste0("^(", RegionNameSub, ")", ".+", "(_P-)", P,"(_R-)", R, ".+(", NameOfSingleCellMask, ")$") #_P- and _R- should be identical
  maskfile <- list.files(path = paste(exportfolder, LocationOfMaskFiles, sep = "/"), pattern = maskpattern, full.names = T)
  #Find single cell edge files
  maskedgepattern <- paste0("^(", RegionNameSub, ")", ".+", "(_P-)", P,"(_R-)", R, ".+(", NameOfSingleCellMaskEdges, ")$")
  maskedgefile <- list.files(path = paste(exportfolder, LocationOfMaskFiles, sep = "/"), pattern = maskedgepattern, full.names = T)
  #Find nuclei files
  masknuclpattern <- paste0("^(", RegionNameSub, ")", ".+", "(_P-)", P,"(_R-)", R, ".+(", NameOfSingleCellNucleiMask, ")$")
  masknuclfile <- list.files(path = paste(exportfolder, LocationOfMaskFiles, sep = "/"), pattern = masknuclpattern, full.names = T)
  
  if (RegionIndex == 1){
    FusedDF <- list()
    PolygonDF <- list()
  }
  if (length(maskfile) == 1){
    # Only generate data if 1 segmentation map is found for current region
    rawfolder <- RAWFolderList[RegionIndex]
    RAWDATA <- read_rawdata_tiffs(rawfolder)
    
    mask <- readTIFF(maskfile, as.is = T)
    # find and sort all roi numbers found in segmentation mask
    # Might have 0 cells stored.
    ROInrs <- sort(unique(c(mask))[unique(c(mask)) > 0])
    if (length(ROInrs) > 10){
      # At least 10 cells should be identified in the segmentation map
      print(paste("Number of cells identified:", length(ROInrs)))
      
      # Find associated slidescan masks, and read info to list
      SlideScanMaskData <- read_slidescan_mask(RegionNameSub, 
                                               LocationOfSlideScanImages, 
                                               LocationOfSlideScanMasks, P, R)
      
      # Generate single cell data with segmentation mask and raw data
      ptime <- system.time({
        FusedDF[[RegionIndex]] <- raw_to_single_cell_data(RAWDATA, rawfolder, 
                                                          mask, ROInrs, 
                                                          maskedgefile, 
                                                          masknuclfile, 
                                                          NuclearMarkers, 
                                                          MembraneMarkers,
                                                          SlideScanMaskData)
      })
      print(ptime)
      # Generate polygons based on segmentation mask
      #PolygonDF[[RegionIndex]] <- mask_to_polygons(mask, ROInrs)
    }
  }
  else{
    print(paste(RegionIndex, ": No Cells found"))
  }
  if (RegionIndex == length(RAWFolderList)){
    FusedDF <- bind_rows(FusedDF, .id = "ImageNumber")
    save(FusedDF, file = paste0(outputfolder, "FusedDF-IFbased.Rda"))
  }
}